#!/usr/bin/env bash

set -euo pipefail

# Configuration
readonly TERRAFORM="${TERRAFORM:-terraform}"
readonly MODULES_DIR="${MODULES_DIR:-modules}"

# Colours for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Colour

# Usage information
usage() {
  cat << EOF
Usage: $(basename "$0") [OPTIONS]

Test all Terraform modules by running init and validate.

OPTIONS:
    -h, --help      Show this help message
    -v, --verbose   Show detailed output for each module
    -m, --module    Test specific module only (relative to modules/)

EXAMPLES:
    $(basename "$0")                         # Test all modules
    $(basename "$0") -v                      # Test all modules with verbose output
    $(basename "$0") -m compute/vpc_network  # Test specific module

EOF
}

# Logging functions
log_info() {
  echo -e "${YELLOW}[INFO]${NC} $*"
}

log_success() {
  echo -e "${GREEN}[PASS]${NC} $*"
}

log_error() {
  echo -e "${RED}[FAIL]${NC} $*"
}

# Discover all module directories
discover_modules() {
  find "${MODULES_DIR}" -name "*.tf" -exec dirname {} \; | sort -u
}

# Test a single module (assumes already initialised)
test_module() {
  local module="$1"
  local verbose="${2:-false}"

  if [[ "$verbose" == "true" ]]; then
    log_info "Testing module: $module"
    if (cd "$module" && "$TERRAFORM" validate); then
      log_success "$module"
      return 0
    else
      log_error "$module"
      return 1
    fi
  else
    if (cd "$module" && "$TERRAFORM" validate >/dev/null 2>&1); then
      log_success "$module"
      return 0
    else
      log_error "$module"
      return 1
    fi
  fi
}

# Main function
main() {
  local verbose=false
  local specific_module=""
  local modules_to_test=()

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -h|--help)
        usage
        exit 0
        ;;
      -v|--verbose)
        verbose=true
        shift
        ;;
      -m|--module)
        specific_module="$2"
        shift 2
        ;;
      *)
        # Treat remaining arguments as module paths
        modules_to_test+=("$1")
        shift
        ;;
    esac
  done

  # Determine modules to test
  if [[ -n "$specific_module" ]]; then
    local target_module="${MODULES_DIR}/${specific_module}"
    if [[ ! -d "$target_module" ]]; then
      log_error "Module '$specific_module' not found"
      exit 1
    fi
    # Check if module contains .tf files
    local tf_files
    tf_files=$(find "$target_module" -maxdepth 1 -name "*.tf" -type f)
    if [[ -z "$tf_files" ]]; then
      log_error "Module '$specific_module' contains no .tf files"
      exit 1
    fi
    modules_to_test=("$target_module")
  elif [[ ${#modules_to_test[@]} -eq 0 ]]; then
    readarray -t modules_to_test < <(discover_modules)
    fi

    if [[ ${#modules_to_test[@]} -eq 0 ]]; then
      log_error "No modules found to test"
      exit 1
    fi

    log_info "Testing ${#modules_to_test[@]} module(s)..."
    echo

  # Test all modules
  local failed_modules=()
  for module in "${modules_to_test[@]}"; do
    if ! test_module "$module" "$verbose"; then
      failed_modules+=("$module")
    fi
  done

  # Summary
  echo
  if [[ ${#failed_modules[@]} -eq 0 ]]; then
    log_success "All modules passed validation!"
    exit 0
  else
    log_error "Failed modules:"
    printf '  %s\n' "${failed_modules[@]}"
    echo
    log_info "For detailed output, run: $(basename "$0") -v -m <module_path>"
    exit 1
  fi
}

main "$@"
